/*
所有权的三条规则
1.每个值都有一个变量，这个变量就是这个值的所有者
2.每个值只能有一个所有者
3.所有者超出作用域的时候，删除这个值
*/
fn main() {
    // 变量作用域
    // 声明前s不可用
    let s = "Hello";
    // 以后可以对s进行操作，可用了
    println!("s is {}", s);
    string_study();
    move_study();
}
// 然后s的作用域结束了，s不可用

// String类型 这个比基础数据类型更加复杂，这个存储在堆上面
// 它可以代表其他的各种复杂数据类型
// 字符串字面值就是不可变的那些字符串
fn string_study() {
    // 如何创建String类型的值
    let mut s = String::from("Hello");
    // 使用push方法，往后面添加一个字符串字面值
    s.push_str(", World");
    println!("{}", s);
}

// 内存和分配
// 字符串直接被硬编码写入文件，速度快也高效
// 但是String的大小不知道，需要在运行时请求内存，通过from方法实现
// 用完以后，要返回内存，Rust会在走出作用域的时候，立刻释放内存，也就是drop函数，自动调用的

// 变量和数据交互的方式：Move 移动
fn move_study() {
    let x = 5;
    let y = x;
    // 这里，整数是固定的值，那么就被放在了Stack里面
    drop(y);

    // 对于String也差不多
    // 但是运行方式是完全不一样的
    let s1 = String::from("Hello");
    let s2 = s1;
    println!("{}", s2);

    // 一个string由三个部分组成
    // 分别是指向内存的指针，一个长度，一个容量，这些在Stack上面
    // 字符串的内容放在heap上面
    // s1给s2的时候，s1的数据都复制了一份，但是指针指向的没有复制
    // 如果两个变量释放，就是释放同一块内存，会报错，二次释放
    // Rust于是就让s1失效，这样释放s1就不会释放任何东西

    // 这个时候使用s1呢？
    // 你会发现报错啦，不能再次使用了
    // println!("{}", s1);

    // 你也发现了，复制不会深拷贝
    // 如果非要深拷贝，那么可以使用克隆这个方法，这样就可以继续访问了
    let s1 = String::from("Hello");
    let s2 = s1.clone();
    println!("{}, {}", s1, s2);

    // 当然啦，对于不可变数据，就不会这样子了，比如
    let x = 5;
    let y = x;
    println!("{}, {}", x, y);
    // 这是因为存在一个Copy复制 trait
    // 只要一个类型实现了copy，那么复制过后原来的数据依旧可用

    // 注意以下这些
    // 1. 任何简单的标量的组合类型都是可以copy的
    // 2. 任何需要分配内存或者某种资源的都不是Copy
    
    // 一些实现copy trait的类型：
    // 所有整数，布尔，字符，浮点，tuple（如果所有字符都是copy的）
}
